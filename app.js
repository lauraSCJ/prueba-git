// --- Librer√≠as ---
const express = require('express'); // Framework web para construir APIs y aplicaciones web.
const { MongoClient } = require('mongodb'); // Driver oficial de MongoDB para interactuar con la base de datos.
const cors = require('cors'); // Middleware para habilitar Cross-Origin Resource Sharing (CORS). Esencial para permitir solicitudes desde diferentes or√≠genes (como tu ESP32 o tu frontend web).

// --- Inicializaci√≥n de la Aplicaci√≥n Express ---
const app = express(); // Crea una instancia de la aplicaci√≥n Express.

// --- Middlewares Esenciales ---
// Habilita CORS para todas las rutas. Permite que cualquier dominio pueda hacer solicitudes a esta API.
app.use(cors());
// Middleware para parsear el cuerpo de las solicitudes entrantes con formato JSON.
// Los datos JSON enviados en el cuerpo de una solicitud POST/PUT estar√°n disponibles en req.body.
app.use(express.json());
// Middleware para parsear cuerpos de solicitud con datos codificados en URL (ej. de formularios HTML simples).
// extended: true permite el parseo de objetos y arrays anidados en el cuerpo.
app.use(express.urlencoded({ extended: true }));

// --- Variables de Configuraci√≥n del Servidor ---
// Define el puerto en el que el servidor escuchar√°.
// process.env.PORT es utilizado por servicios de hosting como Render.com para asignar un puerto din√°micamente.
// Si no est√° definido (ej. en desarrollo local), usar√° el puerto 3000.
const PORT = process.env.PORT || 3000;

// --- Configuraci√≥n de MongoDB ---
// URL de conexi√≥n a tu cl√∫ster de MongoDB Atlas.
// ¬°ADVERTENCIA DE SEGURIDAD! En un entorno de producci√≥n real, esta URL (que contiene usuario y contrase√±a)
// DEBER√çA ser almacenada en una variable de entorno (ej. process.env.MONGO_URI) y no directamente en el c√≥digo.
const URL_CONEXION_MONGO = "mongodb+srv://apiUser:ZKST2xdoY7aif74@clusterapi.ynelw9w.mongodb.net/?retryWrites=true&w=majority&appName=ClusterAPI";
let db; // Variable global para almacenar la instancia de la base de datos conectada.

// Nombres de las bases de datos y colecciones en MongoDB.
const NOMBRE_BASE_DE_DATOS_MONGODB = "Alzheimer";
const COLLECTION_DATOS_EQUIPOS = "datos"; // Colecci√≥n para guardar datos de los equipos (GPS, etc.)
const COLLECTION_PACIENTES_REGISTRADOS = "pacientes"; // Colecci√≥n para guardar datos de nuevos pacientes (nombre, edad, etc.)

// --- Definici√≥n de Rutas de la API ---
const RUTA_ENVIAR_DATOS_EQUIPO = "/enviar"; // Ruta para recibir datos de equipos (POST)
const RUTA_OBTENER_DATOS_EQUIPO = "/recibir"; // Ruta para obtener el dato m√°s reciente de equipos (GET)
const RUTA_REGISTRAR_NUEVO_PACIENTE = "/nuevo-paciente"; // Ruta para registrar un nuevo paciente (POST)

// --- Funci√≥n para Conectar a MongoDB ---
/**
 * Funci√≥n as√≠ncrona para establecer una conexi√≥n con MongoDB Atlas.
 * Si la conexi√≥n es exitosa, asigna la instancia de la base de datos a la variable global db.
 * Si la conexi√≥n falla, registra el error en la consola y termina el proceso del servidor.
 */
async function conexionMongoDB() {
    try {
        const client = new MongoClient(URL_CONEXION_MONGO); // Crea un nuevo cliente de MongoDB.
        await client.connect(); // Intenta conectar al cl√∫ster de MongoDB.
        db = client.db(NOMBRE_BASE_DE_DATOS_MONGODB); // Asigna la base de datos espec√≠fica a la variable db.
        console.log("‚úÖ Conectado a MongoDB Atlas"); // Mensaje de √©xito en la consola.
    } catch (err) {
        console.error("‚ùå Error de conexi√≥n a MongoDB:", err); // Registra el error de conexi√≥n.
        process.exit(1); // Termina el proceso de Node.js con un c√≥digo de error (1).
    }
}

// --- Rutas de la API ---

// POST /nuevo-paciente: Recibe los datos enviados desde el formulario de "Crear Nueva Cuenta"
// para registrar un nuevo paciente en la base de datos.
app.post(RUTA_REGISTRAR_NUEVO_PACIENTE, async (req, res) => {
    try {
        // Registra en consola los datos recibidos en esta ruta para depuraci√≥n.
        console.log(üì• Solicitud POST recibida en ${RUTA_REGISTRAR_NUEVO_PACIENTE}:, req.body);

        // Desestructura los campos esperados del cuerpo de la solicitud (req.body).
        // Estos nombres deben coincidir con los 'name' o 'id' de tus inputs en el HTML del formulario.
        const {
            nombreCuidador,
            edad,
            ocupacion,
            parentesco,
            usuario,
            email,
            telefono,
            password, // Contrase√±a sin cifrar (¬°RECORDATORIO: Cifrar en producci√≥n!)
            confirmPassword
        } = req.body;

        // Validaci√≥n b√°sica de campos obligatorios.
        if (!nombreCuidador || !edad || !usuario || !email || !password || !confirmPassword) {
            return res.status(400).json({
                success: false,
                message: "Faltan campos obligatorios para registrar el paciente."
            });
        }

        // Validaci√≥n de coincidencia de contrase√±as.
        if (password !== confirmPassword) {
            return res.status(400).json({
                success: false,
                message: "Las contrase√±as no coinciden."
            });
        }

        // --- L√≥gica de Negocio Adicional (Recomendado para Producci√≥n): ---
        // 1. Cifrado de Contrase√±a: Utiliza una librer√≠a como 'bcrypt' para hashear la contrase√±a
        //    antes de guardarla en la base de datos. ¬°Esto es CR√çTICO para la seguridad!
        //    Ej: const hashedPassword = await bcrypt.hash(password, 10);
        // 2. Verificaci√≥n de Unicidad: Comprueba si el 'usuario' o 'email' ya existen en la
        //    colecci√≥n pacientesRegistrados para evitar duplicados.
        // 3. Validaci√≥n de Formato: Valida el formato del email, la edad, etc.

        // Accede a la colecci√≥n de pacientes.
        const pacientesCollection = db.collection(COLLECTION_PACIENTES_REGISTRADOS);
        // Inserta el nuevo documento de paciente en la colecci√≥n.
        const result = await pacientesCollection.insertOne({
            nombreCuidador,
            edad: parseInt(edad), // Asegura que la edad se guarde como n√∫mero
            ocupacion,
            parentesco,
            usuario,
            email,
            telefono,
            password_hash: password, // Aqu√≠ DEBER√çA ir la contrase√±a cifrada
            fechaRegistro: new Date() // Marca de tiempo de cu√°ndo se registr√≥ el paciente.
        });

        // Env√≠a una respuesta exitosa al cliente (el navegador web).
        res.status(201).json({
            success: true,
            message: Paciente agregado exitosamente a la colecci√≥n ${COLLECTION_PACIENTES_REGISTRADOS}.,
            data: {
                id: result.insertedId, // El ID √∫nico generado por MongoDB para el nuevo documento.
                usuario: usuario,
                email: email
            }
        });

    } catch (err) {
        // Manejo de errores: Registra el error y env√≠a una respuesta de error al cliente.
        console.error(‚ùå Error en POST ${RUTA_REGISTRAR_NUEVO_PACIENTE}:, err);
        res.status(500).json({
            success: false,
            message: "Error interno del servidor al registrar paciente.",
            error: err.message // Env√≠a el mensaje de error para depuraci√≥n (evitar en producci√≥n).
        });
    }
});

// GET /recibir: Devuelve el dato de equipo m√°s reciente de la colecci√≥n datos.
// Este endpoint es √∫til para que tu frontend web pueda mostrar la √∫ltima ubicaci√≥n.
app.get(RUTA_OBTENER_DATOS_EQUIPO, async (req, res) => {
    try {
        console.log(üì• Solicitud GET recibida en ${RUTA_OBTENER_DATOS_EQUIPO}.);

        // Busca el documento m√°s reciente en la colecci√≥n COLLECTION_DATOS_EQUIPOS.
        // .sort({ fechaRecepcionServidor: -1 }) ordena los documentos de forma descendente por la fecha de recepci√≥n.
        // .limit(1) asegura que solo se obtenga el primer (m√°s reciente) documento.
        // .toArray() convierte el cursor de MongoDB en un array.
        const datoMasReciente = await db.collection(COLLECTION_DATOS_EQUIPOS).find().sort({ fechaRecepcionServidor: -1 }).limit(1).toArray();

        // Si no se encuentra ning√∫n dato en la colecci√≥n, env√≠a un estado 404 (Not Found).
        if (datoMasReciente.length === 0) {
            return res.status(404).json({ message: 'No hay datos de equipos a√∫n.' });
        }

        // Env√≠a el dato m√°s reciente como respuesta JSON al cliente.
        res.json(datoMasReciente[0]);
    } catch (error) {
        // Manejo de errores para la ruta GET.
        console.error(‚ùå Error al obtener el dato en GET ${RUTA_OBTENER_DATOS_EQUIPO}:, error);
        res.status(500).json({
            success: false,
            message: 'Error interno del servidor al obtener el dato.',
            error: error.message
        });
    }
});

// POST /enviar: Por aqu√≠ llegan los datos de ubicaci√≥n y tiempo que los equipos (ESP32) env√≠an.
// Este endpoint est√° dise√±ado para guardar la estructura exacta que tu ESP32 est√° enviando.
app.post(RUTA_ENVIAR_DATOS_EQUIPO, async (req, res) => {
    try {
        // Muestra en consola el cuerpo completo del JSON recibido del ESP32.
        console.log(üì• Solicitud POST de equipo recibida en ${RUTA_ENVIAR_DATOS_EQUIPO}:, req.body);

        // Desestructura los campos principales del JSON recibido para una validaci√≥n r√°pida.
        const { fecha, hora, ubicacion, dispositivo } = req.body;

        // Validaci√≥n b√°sica: asegura que el JSON contenga los campos esenciales de la tarjeta.
        if (!fecha || !hora || !ubicacion || !dispositivo) {
            return res.status(400).json({
                success: false,
                message: "Faltan campos obligatorios (fecha, hora, ubicacion, dispositivo) en el JSON del equipo."
            });
        }

        // Crea el documento a insertar en MongoDB.
        // El operador ...req.body copia todas las propiedades del JSON recibido (fecha, hora, ubicacion, dispositivo)
        // directamente como campos de nivel superior en el nuevo documento de MongoDB.
        const documentoEquipo = {
            ...req.body, // Copia los datos de la tarjeta (longitud, latitud, fecha, hora, dispositivo)
            fechaRecepcionServidor: new Date() // A√±ade una marca de tiempo del servidor (en UTC) al momento de la recepci√≥n.
        };

        // Inserta el documento en la colecci√≥n de datos de equipos (COLLECTION_DATOS_EQUIPOS).
        const resultadoInsercion = await db.collection(COLLECTION_DATOS_EQUIPOS).insertOne(documentoEquipo);

        // Env√≠a una respuesta exitosa (201 Created) al ESP32.
        res.status(201).json({
            success: true,
            message: 'Dato de equipo guardado exitosamente.',
            id: resultadoInsercion.insertedId // Devuelve el ID generado por MongoDB.
        });
    } catch (error) {
        // Manejo de errores: Registra el error y env√≠a una respuesta de error al cliente.
        console.error(‚ùå Error al guardar el dato en POST ${RUTA_ENVIAR_DATOS_EQUIPO}:, error);
        res.status(500).json({
            success: false,
            message: 'Error interno del servidor al guardar el dato del equipo.',
            error: error.message
        });
    }
});

// --- Inicio del Servidor ---
// El servidor Express comienza a escuchar en el puerto definido.
// La conexi√≥n a MongoDB se establece de forma as√≠ncrona ANTES de que el servidor empiece a aceptar solicitudes.
// Esto asegura que la base de datos est√© lista cuando lleguen las peticiones.
app.listen(PORT, async () => {
    await conexionMongoDB(); // Espera a que la conexi√≥n a MongoDB se establezca.
    console.log(üöÄ Servidor listo en http://localhost:${PORT} (ejecut√°ndose localmente));
    console.log(üåç URL de la API (si est√° desplegada en Render): https://mi-api-express.onrender.com);
});